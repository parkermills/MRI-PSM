%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% @name import_fid.m
% @author Parker Mills, Ahrens Lab, Carnegie Mellon
% @brief Imports a single-image Bruker-format k-space file and reconstructs.
%        If the k-space data was generated by FISP_PHM, this will be considered.
%
%
% ==================== INPUT PARAMETERS ======================
% @param    filename       (String)       Path to k-space data file
%
% @param    k_space_type   (String)       '3d': True 3D k-space volume acquisition
%                                         '2d': Slice stack of 2D images
%                                         '4d': EXPERIMENTAL, a multi-echo image
%
% @param    ordering       (String)       '3d-2d': If data ordering is k-space Z-lines (or slices) first, then 2d encoding
%                                                  This is typically used when multiple slices are acquired during a single TR period
%                                         '2d-3d': If data ordering is k-space Y-lines first, then Z-lines/slices
%                                                  This is typically used when entire slices are acquired in sequence, or for 3D acquisitions
%
% @param    RARE_factor    (Float)        The RARE factor for acquisition (fast spin-echo)
%                                         0 or [] indicates NOT a RARE Sequence
%
% @param    B0             (Float)        Primary magnetic field strength B0 (MHz or Tesla - both work)
% @param    TE             (Float)        Echo time (milliseconds)
% @param    fov            (1D Float)     Field of view of data in CENTIMETERS (e.g. [1.1 1.3 1.1])
%
% @param    read_dim       (1D Float)     K-space dimensions: [x_size y_size z_size]
%                                         When processing Bruker data, often the x_size (readout dimension) is larger (often 2x) than requested.
%
% @param    reco_dim       (1D Float)     Desired dimensions of reconstruction: [x_size y_size z_size].
%                                         Assumes equivalent to k-space dimensions if empty (i.e., [])
%                                         If z_size is provided when this is a stack of 2D images it will be ignored.
%
% @param    noise          (Float)        Standard deviation of gaussian-distributed noise added to k-space
%                                         Setting this to 0.0 or [] results in no noise addition, and is the default.
%
% @param    NEX_scheme_y   (1D Float)     Vector representing NEX(y). If  vector empty (i.e., []), assume equal sampling (e.g., keyhole_factor = 1)
% @param    NEX_scheme_z   (1D Float)     Vector representing NEX(z). If  vector empty (i.e., []), assume equal sampling (e.g., keyhole_factor = 1)
%
% ==================== RETURNED DATA =========================
% @return   MRIdata.complex           (2D/3D Float)  Output 2D or 3D complex data reconstruction
%                  .mag               (2D/3D Float)  Output 2D or 3D magnitude image reconstruction
%                  .phase             (2D/3D Float)  Output 2D or 3D phase image reconstruction
%                  .mag_deconvolved   (2D/3D Float)  If non-normal NEX scheme, magnitude image deconvolved by Lucy-Richardson algorithm
%                  .k_space           (2D/3D Float)  Raw k-space
%
% ====================== ASSUMPTIONS =========================
% @assume   K-space file format is Bruker-formatted: 32-bit signed integers, interlaced real & imaginary parts.
% @assume   The Bruker k-space file is NOT multi-echo, it is only a single 2D stack or 3D volume
% @assume   Ordering goes: [REAL,IMAG], [K_SPACE_LINE(z,y)] x keyhole(y), [K_SPACE_LINE(z,y+1)] x keyhole(y+1), [K_SPACE_LINE(z+1, y)] x keyhole(y), etc.
%
%
% ==================== DISPLAYED PRODUCTS ====================
% @product  (Figure)  Sample of central slice in volume after deconstruction
% @product  (Figure)  If 3D, a profile slice of volume
% @product  (Figure)  If keyhole, show corrected image
%
%
% ==================== SAMPLE USAGE ==========================
% MRIdata = import_fid(filename, k_space_type, ordering, RARE_factor, B0, TE, read_dim, reco_dim, noise, NEX_scheme_y, NEX_scheme_z, bigEndian);
% FISP_PHMdata = import_fid('fid', '2d', '2d-3d', [], 4.7 , 11, [1.1 1.1 1.4], [128 128 12],  [256 256 12], 0.0, NEX_scheme_128, NEX_scheme_128, 0);
% FISPdata     = import_fid('fid', '3d', '2d-3d', [], 4.7,   4, [1.1 1.1 1.4], [64 64 64],    [],           0.0, [],[],                          0);
% RAREdata     = import_fid('fid', '3d', '2d-3d',  8, 4.7,   4, [1.1 1.1 1.4], [64 64 64],    [],           0.0, [],[],                          0);
% GREdata      = import_fid('fid', '3d', '2d-3d', [], 11.7, 10, [1.1 1.1 1.4], [128 128 128], [],           0.0, [],[],                          0);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


function MRIdata = import_fid(k_space_type, ordering, RARE_factor, B0, TE, fov, read_dim, reco_dim, obj_order, automated, noise, NEX_scheme_y, NEX_scheme_z, bigEndian)


%% Preferences
filename = 'fid';
pref_endian_default = 0; %0 is littleEndian


%% Perform Data/Dimension-related Sanity Checks

% Ensure all 3 dimensions are given by user for read_dim
if( length(read_dim) ~= 3 )
    error('import_fid: read_dimensions vector must have 3 elements: [x_dim, y_dim, z_dim]. Quitting.');
end

% Ensure either no, or 3 dimensions are given by user for reco_dim
if(~exist('reco_dim','var'))
    warning('import_fid: reco_dimensions not specified, will reconstruct to same size as read dimensions');
    reco_dim = read_dim;
else
    if( (length(reco_dim) ~= 3) && ~isempty(reco_dim) )
        error('import_fid: reco_dimensions must have 3 elements');
    end
end

% Ensure k_space_type is specified
if(~strcmp(k_space_type,'2d') && ~strcmp(k_space_type,'3d') && ~strcmp(k_space_type,'4d'))
    error('import_fid: k_space_type must be either "2d" (i.e., slice stacks) or "3d" (i.e., true 3D k-space) or "4d" (experimental)');
end

% Ensure data ordering is specified
if( ~strcmp(ordering,'3d-2d') && ~strcmp(ordering,'2d-3d')  )
    error('import_fid: ordering must be either "3d-2d" (e.g., MSME sequence), "2d-3d" (e.g., FISP sequence, Other sequences)');
end

% Ensure FOV is specified
if( length(fov) ~= 3)
    error('import_fid: fov vector must have 3 elements: [fov_x, fov_y, fov_z]. Quitting.');
end

% Ensure endianness is specified
if(~exist('bigEndian','var'))
    bigEndian = 0;
end

% Ensure automated flag is specified
if(~exist('automated','var'))
    automated = 'manual';
end


%% Perform Initializations

% Open File and read in data
fd = fopen(filename);

%If data is bigEndian
if(bigEndian)
    data = fread(fd,inf,'*int32');
    data = single(swapbytes(data)); % Single precision
else
    %If data is littleEndian
    data = single(fread(fd,inf,'int32'));
end

% Store read dimensions
k_line_length = read_dim(1);
k_lines_y     = read_dim(2);
k_lines_z     = read_dim(3);

% If no reco dimensions (reco_dim) are given, set reco_dim to read_dim
if(isempty(reco_dim))
    reco_dim = [ k_line_length    k_lines_y    k_lines_z ];
end

% Store reco dimensions
reco_x = reco_dim(1);
reco_y = reco_dim(2);
reco_z = reco_dim(3);

% Spit out voxel size to give people reference
resolution_x = 10000 * fov(1)/read_dim(1);
resolution_y = 10000 * fov(2)/read_dim(2);
resolution_z = 10000 * fov(3)/read_dim(3);
disp(['Voxel sizes (microns) are: ',num2str(resolution_x),' ',num2str(resolution_y),' ',num2str(resolution_z)]);

% Set default phase shifts per pixel.
phase_shift_x = 0;
phase_shift_y = 0;
phase_shift_z = 0;

% Set advanced phase shifts per pixel.
% (4/4)pi = 180 degree phase shift per px, (2/4)pi = 90 degree shift per px, etc.
% What I've seen so far:
% A [256 256 128] set has a shift of [6/4 4/4 4/4] (lesleybrain0)
% A [256 256 128] set has a shift of [4/4 6/4 4/4] (oldheart3)
% A [128 128 128] set has a shift of [4/4 4/4 4/4].
% Could it be 4/4 for 128 and 6/4 for 256?
%

switch k_line_length
    case 512
        phase_shift_x = (4/4) * pi;
    case 256
        phase_shift_x = (4/4) * pi; % Set: 6/4 ex vivo lesleybrains; 4/4 hearts; 4/4 in vivo lesleybrain; 6/4 paul cells
    case 128
        phase_shift_x = (4/4) * pi;
    otherwise
        phase_shift_x = (4/4) * pi;
end

switch k_lines_y
    case 256
        phase_shift_y = (4/4) * pi;
    case 128
        if(RARE_factor > 1)
            phase_shift_y = (4/4) * pi + pi / 8;
        else
            phase_shift_y = (4/4) * pi;
        end
    case 96
        phase_shift_y = (4/4) * pi;
    case 64
        phase_shift_y = (4/4) * pi;  %no idea
    otherwise
        phase_shift_y = (4/4) * pi;
end

switch k_lines_z
    case 256
        phase_shift_z = (4/4) * pi;
    case 128
        phase_shift_z = (4/4) * pi;
    case 64
        phase_shift_z = (4/4) * pi; % no idea
    otherwise
        phase_shift_z = (4/4) * pi;
end





%% Perform NEX-related Sanity Checks

% If NEX_scheme is NULL, set it to be all ones
custom_NEX_scheme_y = 1;
custom_NEX_scheme_z = 1;
if(~exist('NEX_scheme_y','var'))
    NEX_scheme_y = ones(1,k_lines_y); % Create a default 2D NEX_scheme
    custom_NEX_scheme_y = 0;
else
    if (isempty(NEX_scheme_y))
        NEX_scheme_y = ones(1,k_lines_y); % Create a default 2D NEX_scheme
        custom_NEX_scheme_y = 0;
    end
end
if(~exist('NEX_scheme_z','var'))
    NEX_scheme_z = ones(1,k_lines_z); % Create a default 2D NEX_scheme
    custom_NEX_scheme_z = 0;
else
    if(isempty(NEX_scheme_z))
        NEX_scheme_z = ones(1,k_lines_z); % Create a default 2D NEX_scheme
        custom_NEX_scheme_z = 0;
    end
end

% If either NEX_scheme is a matrix, alert user
if(   ~isvector(NEX_scheme_y)  ||    ~isvector(NEX_scheme_z)   )
    error('import_fid: NEX_scheme is 2D when expecting 1D. Quitting.');
end

% If there is more data than expected
k_line_length
sum(sum(NEX_scheme_y' * NEX_scheme_z))
if (length(data) > 2 * k_line_length * sum(sum(NEX_scheme_y' * NEX_scheme_z))   )
    if(~strcmp(k_space_type,'4d')); % Multi-echo patch
        figure;plot(data);
        %%%%%%%error(['import_fid: found ', num2str(length(data) / (2 * k_line_length * sum(sum(NEX_scheme_y' * NEX_scheme_z)) )   ),' times as much data than expected...perhaps your dimensions are too small? Quitting.']);
    end
end

% If there is less data than expected
if(length(data) < 2 * k_line_length * sum(sum(NEX_scheme_y' * NEX_scheme_z))   )
    error(['import_fid: found ', num2str(length(data) / (2 * k_line_length * sum(sum(NEX_scheme_y' * NEX_scheme_z))  )  ),' times the data expected...perhaps your dimensions are too large? Quitting.']);
end

% Check that provided RARE_factor is a multiple of the lines of k-space
if(~isempty(RARE_factor) && (RARE_factor > 0))
    if(mod(k_lines_y, RARE_factor) ~= 0)
        error(['import_fid: Number of y-lines, ', num2str(k_lines_y), ' is not a multiple of the provided RARE_factor, ',num2str(RARE_factor)]);
    end
end


% Show NEX scheme
if(custom_NEX_scheme_y)
    figure; plot(NEX_scheme_y); title(['Y-dimension NEX Scheme of Imported Data']);
    figure; plot(NEX_scheme_z); title(['Z-dimension NEX Scheme of Imported Data']);
    images(NEX_scheme_y' * NEX_scheme_z); title(['NEX Coverage of combined X- & Y-directions']);
end



%% Read Bruker k-space (interlaced real and imaginary numbers) into real & imaginary vectors
raw_fid = reshape(data, 2, 2* k_line_length *   sum(sum(NEX_scheme_y' * NEX_scheme_z))    );
clear data; %Free RAM
fid = single(raw_fid(1,:) + 1i * raw_fid(2,:)); % Combine real and imaginary components into 1 vector
clear raw_fid; %Free RAM



%% Handle RARE pulse sequence's data reordering
if(RARE_factor > 1)
    
    % Initialize kspace to be filled from RARE fid
    kspace = zeros([ k_line_length    k_lines_y    k_lines_z ]);
    
    fid_index = 1;
    
    for TR_period = 1:k_lines_y / RARE_factor
        for slice = 1:k_lines_z
            for echo = 1:RARE_factor
                kspace(:, (echo - 1) * k_lines_y / RARE_factor + TR_period, slice) = fid(fid_index:fid_index + k_line_length - 1);
                fid_index = fid_index + k_line_length;
            end
        end
    end
    
    fid = kspace;
    clear kspace
end


%% Handle FLASH pulse sequence's data reordering
if(RARE_factor == 1)
    
    % Initialize kspace to be filled from RARE fid
    kspace = zeros([ k_line_length    k_lines_y    k_lines_z ]);
    
    fid_index = 1;
    
    for TR_period = 1:k_lines_y
        for slice = 1:k_lines_z
            kspace(:, TR_period, slice) = fid(fid_index:fid_index + k_line_length - 1);
            fid_index = fid_index + k_line_length;
        end
    end
    
    fid = kspace;
    clear kspace
end


fid = reshape(fid,[k_line_length, k_lines_y, k_lines_z]);
MRIdata.k_space = fid;
clear fid; %Free RAM

%% Process each line of k-space, reordering and considering keyhole if it was employed
% images(MRIdata.k_space(:,:,1))
% images(MRIdata.k_space(:,:,2))
% images(MRIdata.k_space(:,:,3))
% images(fftshift(ifft2(MRIdata.k_space(:,:,1)))); title('temp image1');
% images(fftshift(ifft2(MRIdata.k_space(:,:,2)))); title('temp image2');
% images(fftshift(ifft2(MRIdata.k_space(:,:,3)))); title('temp image3');

% MRIdata.k_space = single(zeros(k_line_length, k_lines_y, k_lines_z));
% data_pointer = 1;
%
% if(strcmp(ordering,'2d-3d'))
%
%     % For each z-dimension position
%     for grad_z = 1:k_lines_z
%         for z_averaging_hold = 1:NEX_scheme_z(grad_z)
%
%             % For each y-dimension position
%             for grad_y = 1:k_lines_y
%                 for y_averaging_hold = 1:NEX_scheme_y(grad_y)
%
%                     start = data_pointer;
%                     stop = data_pointer + k_line_length - 1;
%                     MRIdata.k_space(:,grad_y,grad_z) = MRIdata.k_space(:,grad_y,grad_z) + fid(start:stop)';
%                     data_pointer = stop + 1;
%
%                 end
%             end
%
%         end
%     end
%
%     % 3d-2d case, same as above but condensed
% else
%     % For each z-dimension position
%     for grad_y = 1:k_lines_y
%         for y_averaging_hold = 1:NEX_scheme_y(grad_y)
%
%             % For each y-dimension position
%             for grad_z = 1:k_lines_z
%                 for z_averaging_hold = 1:NEX_scheme_z(grad_z)
%
%                     start = data_pointer;
%                     stop = data_pointer + k_line_length - 1;
%                     MRIdata.k_space(:,grad_y,grad_z) = MRIdata.k_space(:,grad_y,grad_z)+ fid(start:stop)';
%                     data_pointer = stop + 1;
%
%                 end
%             end
%
%         end
%     end
% end





%% Add Gaussian (Normal) Noise signals to real and imaginary channels
if exist('noise','var')
    MRIdata.k_space = single(MRIdata.k_space + noise * (randn(size(MRIdata.k_space)) + 1i * randn(size(MRIdata.k_space))));
end



%% Calculate complex data

MRIdata.complex = single(zeros(reco_dim(1), reco_dim(2), reco_dim(3)));

if(strcmp(k_space_type,'3d'))  % 3D Case
    MRIdata.complex = single(ifftshift(ifftn(MRIdata.k_space,[reco_dim(1) reco_dim(2) reco_dim(3)])));
else
    for slice = 1:k_lines_z  % 2D Case
        MRIdata.complex(:,:,slice) = single(ifftshift(ifft2(MRIdata.k_space(:,:,slice),reco_dim(1), reco_dim(2))));
    end
end



%% Calculate phase image
% Note: If you change the size of your image, phase_shift_x/y/z all change by the relationship ((res_new/res_old-1)(pi/2) -OR IT IS- ((res_old/res_new-1)(pi/2)

% Computer the phase angle for each pixel using the MATLAB angle() function
if(strcmp(k_space_type,'3d'))
    phase = angle(ifftshift(ifftn(MRIdata.k_space,[reco_dim(1) reco_dim(2) reco_dim(3)])));
end

if(strcmp(k_space_type,'2d'))
    for slice = 1:k_lines_z
        phase(:,:,slice) = angle(ifftshift(ifft2(MRIdata.k_space(:,:,slice),reco_dim(1), reco_dim(2))));
    end
end

% Add pi to both phase products so their range goes from [-pi..pi]
phase = phase + pi;

for k = 1:reco_x % Phase alternation correction in X-direction
    phase(k,:,:) = mod(   phase(k,:,:) + k * phase_shift_x , 2.0 * pi);
end

for k = 1:reco_y %Phase alternation correction in Y-direction
    phase(:,k,:) = mod( phase(:,k,:) + k * phase_shift_y, 2.0 * pi);
end

for k = 1:reco_z %Phase alternation correction in Z-direction
    phase(:,:,k) = mod(phase(:,:,k)+ k * phase_shift_z, 2.0 * pi);
end

% Subtract pi so that range goes from [-pi..pi]
phase = phase - pi;




%% Calculate magnitude image

% Display k-space normalized! (Better for visualization purposes)
for k = 1:k_line_length
    k_space_normalized(k,:,:) =  reshape(MRIdata.k_space(k,:,:), [k_lines_y k_lines_z])  ./  sqrt(NEX_scheme_y' * NEX_scheme_z)  ;
end

if(strcmp(k_space_type,'3d'))
    MRIdata.mag = sqrt(  real(ifftshift(ifftn(MRIdata.k_space, [reco_dim(1) reco_dim(2) reco_dim(3)]))).^2   +   imag(ifftshift(ifftn(MRIdata.k_space, [reco_dim(1) reco_dim(2) reco_dim(3)]))).^2  );
    mag_normalized = sqrt(  real(ifftshift(ifftn(k_space_normalized))).^2   +   imag(ifftshift(ifftn(k_space_normalized))).^2  );
end

if(strcmp(k_space_type,'2d'))
    for slice = 1:k_lines_z
        MRIdata.mag(:,:,slice)    = abs(ifftshift(ifft2(MRIdata.k_space(:,:,slice)     ,reco_dim(1), reco_dim(2))));
        mag_normalized(:,:,slice) = abs(ifftshift(ifft2(k_space_normalized(:,:,slice)  ,reco_dim(1), reco_dim(2))));
    end
end



%% Perform filtering if necessary
% Note: One iteration of Lucy-Richardson appears to produce the best result
if(custom_NEX_scheme_y)
    psf = real(fftshift(fft(NEX_scheme_y)));
    mag_deconvolved_17 = deconvlucy(MRIdata.mag,abs(psf),17); % 17 iterations
    mag_deconvolved_1  = deconvlucy(MRIdata.mag,abs(psf), 1); % EXPORTED VERSION - 1 iteration
end




%% Display figures and prompt for shifting if they are off center

if(~strcmp(automated,'automated'))
    % Shift left-right, up-down
    fig1 = images(MRIdata.mag); title(['Central magnitude image reconstructed from NEX scheme']); % Display center slice of magnitude image
    reply = input('If x/y scrolling OK in field-of-view? y/n [y]: ', 's');
    while strcmp(reply,'n')
        down_shift = input('Scroll down how many pixels? [integer]:');
        right_shift = input('Scroll right how many pixels? [integer]:');
        MRIdata.mag = circshift(MRIdata.mag, [down_shift right_shift, 0]);
        phase = circshift(phase, [down_shift right_shift, 0]);
        %phase_hamming = circshift(phase_hamming, [down_shift right_shift, 0]);
        MRIdata.complex = circshift(MRIdata.complex, [down_shift right_shift, 0]);
        if(custom_NEX_scheme_y)
            mag_deconvolved_1 = circshift(mag_deconvolved_1, [down_shift right_shift, 0]);
        end
        if(ishandle(fig1)) close(fig1); end % Close the figure if still present
        fig1=images(MRIdata.mag);
        reply = input('Scrolling OK now?: [Y/N]', 's');
    end
    if(ishandle(fig1)) close(fig1); end % Close the figure if still present
    
    
    % If 3D, shift in 3D as well
    if(strcmp(k_space_type,'3d'))
        fig1=images(reshape(MRIdata.mag(:,floor(reco_dim(2)/2.0),:),reco_dim(1),reco_dim(3))); title(['Slice through center of 3D volume reconstruction']);
        reply = input('If x/y scrolling OK in field-of-view? y/n [y]: ', 's');
        while strcmp(reply,'n')
            right_shift = input('Scroll right how many pixels? [integer]:');
            MRIdata.mag = circshift(MRIdata.mag, [0, 0, right_shift]);
            phase = circshift(phase, [0, 0, right_shift]);
            %phase_hamming = circshift(phase_hamming, [0, 0, right_shift]);
            MRIdata.complex = circshift(MRIdata.complex, [0, 0, right_shift]);
            if(custom_NEX_scheme_y)
                mag_deconvolved_1 = circshift(mag_deconvolved_1, [0, 0, right_shift]);
            end
            if(ishandle(fig1)) close(fig1); end % Close the figure if still present
            fig1=images(reshape(MRIdata.mag(:,floor(reco_dim(2)/2.0),:),reco_dim(1),reco_dim(3)));
            reply = input('Scrolling OK now?: [Y/N]', 's');
        end
        if(ishandle(fig1)) close(fig1); end % Close the figure if still present
    end
    
end


%% If custom NEX scheme, show related figures
if(custom_NEX_scheme_y)
    figure; plot(psf);  title(['Point-Spread Function for NEX Reconstruction Scheme']);
    images(mag_deconvolved_17); title(['Image reconstructed from NEX scheme then corrected using 17 iterations of Lucy-Richardson deconvolution algorithm'])
    images(mag_deconvolved_1); title(['Image reconstructed from NEX scheme then corrected using 1 iteration of Lucy-Richardson deconvolution algorithm'])
end



%% Put objects into MRIdata structure
MRIdata.k_space_type = k_space_type;
MRIdata.phase = single(phase);
%MRIdata.phase_hamming = single(phase_hamming);
if(custom_NEX_scheme_y)
    MRIdata.mag_deconvolved = single(mag_deconvolved_1);
    MRIdata.mag_normalized = single(mag_normalized);
end
MRIdata.resolution = [resolution_x resolution_y resolution_z];
MRIdata.B0 = B0;
MRIdata.TE = TE;



%% Reorder slices if necessary
if(obj_order)
    for i = 1:reco_dim(3)
        k_space_temp(:,:,obj_order(i)) = MRIdata.k_space(:,:,i);
        complex_temp(:,:,obj_order(i)) = MRIdata.complex(:,:,i);
        mag_temp(:,:,obj_order(i)) = MRIdata.mag(:,:,i);
        phase_temp(:,:,obj_order(i)) = MRIdata.phase(:,:,i);
    end
    MRIdata.k_space = k_space_temp;
    MRIdata.complex = complex_temp;
    MRIdata.mag = mag_temp;
    MRIdata.phase = phase_temp;
end


%% View final image if not automated
if(~strcmp(automated,'automated'))
    images(MRIdata.mag);
end


%%%%%%%%%%%%%%%
%     EOF
%%%%%%%%%%%%%%%
